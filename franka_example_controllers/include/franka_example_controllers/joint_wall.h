// Copyright (c) 2019 Franka Emika GmbH
#pragma once

// clang-format off
/**
 * @file joint_wall.h
 * Contains functions for calculating torques generated by virtual walls.
 |<---- PD_zone_width ------>|<---D_zone_width--->|                  |<---D_zone_width--->|<--- PD_zone_width --->|
 |:::::::::::::::::::::::::::|- - - - - - - - - - |                  | - - - - - - - - - -|:::::::::::::::::::::::|
 ^ soft_lower_joint_position_limit                   normal ^ range               soft_upper_joint_position_limit ^
        PD_zone_boundary_min ^                                                            ^ PD_zone_boundary_max
                              D_zone_boundary_min ^                  ^ D_zone_boundary_max
*/
// clang-format on

namespace franka_example_controllers {

class JointWall {
 public:
  /**
   * Creates a JointWall instance with default params.
   */
  JointWall() = delete;

  /**
   * Creates a JointWall instance with configuable params.
   * @param[in] soft_upper_joint_position_limit (rad)
   * @param[in] soft_lower_joint_position_limit (rad)
   * @param[in] PD_zone_width (meter)
   * @param[in] D_zone_width (meter)
   * @param[in] PD_zone_stiffness (N*meter/rad)
   * @param[in] PD_zone_damping (N*meter*s/rad)
   * @param[in] D_zone_damping (N*meter*s/rad)
   */
  JointWall(const double& soft_upper_joint_position_limit,
            const double& soft_lower_joint_position_limit,
            const double& PD_zone_width,
            const double& D_zone_width,
            const double& PD_zone_stiffness,
            const double& PD_zone_damping,
            const double& D_zone_damping);

  /**
   * Computes the torque with given q and dq. Be aware that the torque is also affected by previous
   * states.
   * @param[in] q
   * @param[in] dq
   * @return the resulting torque
   */
  double computeTorque(const double& q, const double& dq);

  /**
   * Resets the initialized flag
   */
  void reset();

 private:
  /* Indicates the status of moving wall, which occurs after initializing the state inside joint
   * wall.
   */
  enum class MotionInWall {
    EnteringNormal,
    PenetratingLowerLimit,
    LeavingLowerLimit,
    PenetratingUpperLimit,
    LeavingUpperLimit
  };

  //! Joint wall parameters
  double soft_upper_joint_position_limit_{0};
  double soft_lower_joint_position_limit_{0};
  double PD_zone_width_{0};
  double D_zone_width_{0};
  double PD_zone_stiffness_{0};
  double PD_zone_damping_{0};
  double D_zone_damping_{0};

  //! Indicates whether the instance has been initialized
  bool initialized_{false};

  /* Indicates whether the joint wall is still moving, which occurs after initializing the state
   * inside joint wall.
   */
  bool moving_wall_{false};

  //! Zone width scale
  double zone_width_scale_{1};

  //! Checks if x is in range [low, high]
  static bool inRange(double low, double high, double x);

  //! Check if the input is positive number, if not print error and return its abs
  static double positiveCheck(double value);

  //! Initializes the computation
  void init(const double& q, const double& dq);

  //! Moves the wall with given state if the state is initialized inside the wall
  void adjustMovingWall(const double& q, const double& dq);

  //! Checks the motion type in joint wall
  MotionInWall getMotionInWall(const double& q, const double& dq) const;
};
}  // namespace franka_example_controllers
